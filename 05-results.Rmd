# Results

```{r}
library(tidyverse)
library(patchwork)
library(readr)
library(ggplot2)
```

```{r}
job <- read_csv("finalJobs.csv")
```

## Most major job category

To help job seekers realize how many job postings are available for each job category and the competitiveness of various categories of jobs so that they can choose a more suitable job, We want to know the demand for different categories of jobs in New York city. From this job posting data variable "Job Category", for each job posting, our group extract the job category that can best represent the job, and store them and their counts in a new data frame "category".

```{r}
categorytrans <-job%>%select(`Job Category`, `Job ID`) %>% mutate(`Job Category` = as.character(`Job Category`),`Job Category` = gsub("([A-Za-z]+).*", "\\1", job$`Job Category`))

categorytrans$'Job Category'[which(categorytrans$`Job Category` == "Constituent")] <- "Constituent Services"

category <-
  as.data.frame(categorytrans["Job Category"]) %>%
  filter(!is.na(`Job Category`)) %>%
  group_by(`Job Category`) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
  
ggplot(category, aes(x = fct_reorder(`Job Category`,count), y = count)) +
  geom_col(color = "white", fill = "dodgerblue") +
  ggtitle("Most Major Job Category") +
  labs(x = "Category", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_flip()
```

From the graph above, we can find that the number of job posting for "Technology" is largest, which is more than 450, and the number of job posting for "Clerical" is smallest. For "Technology", "Constituent Services", and "Engineering", these three job categories have the top three number of job postings. If people want to choose jobs from these categories, they will have more choices than people who choose from "Social", "Information", and "Clerical".

```{r}
job$category = categorytrans$`Job Category`
job=job%>%filter(!is.na(category))
```

## Relationship of Salary & Category and Salary & Degree Requirement

For people who are finding jobs, the number of salary is always one of the most important information they are interested in. To make our graphs more useful and not to disappoint the job seekers, we choose the lower bound of salary range from each job posting whose salary frequency is annual as the value of salary. Then we create the box plots related to salary & job category and related to salary & degree requirement.

```{r}
Annualjob=job[job$`Salary Frequency`=="Annual",]
ggplot(Annualjob,aes(x = reorder(category,`Salary Range From`,FUN=median), y = `Salary Range From`/1000)) +
geom_boxplot( fill = "dodgerblue") +
ggtitle("Min Annual Salaries range by Job Categories") + 
labs(x = "Job Category", y = "Min Annual Salary(unit: 1,000 usd)") + 
ylim(c(0,200))+
theme(plot.title = element_text(hjust = 0.5)) +
  coord_flip()
```

From the graph above, 

```{r}
Annualjob=Annualjob%>%filter(!is.na(degreereq))
ggplot(Annualjob,aes(x = reorder(degreereq,`Salary Range From`,FUN=median), y = `Salary Range From`/1000)) +
geom_boxplot( fill = "dodgerblue") +
ggtitle("Min Annual Salaries range by degree") + 
labs(x = "Degree requirement", y = "Min Annual Salary(unit: 1,000 usd)") + 
ylim(c(0,200))+
theme(plot.title = element_text(hjust = 0.5)) +
  coord_flip()

```


```{r}
cleveland2 <- job%>%select(`category`, `Job ID`,`residency`) %>%
  drop_na(`residency`) %>%group_by(`category`,`residency`) %>%
  summarise(count = n()) 

cleveland2<-cleveland2%>%pivot_wider(names_from = `residency`, values_from = count) %>%
  mutate(Total=`required`+`not required`) %>%
  ungroup() %>%
  pivot_longer(cols=!`category`, names_to="type", values_to="count") 
cleveland2[is.na(cleveland2)] <- 0
cleveland2$count[which(cleveland2$type == "Total"&cleveland2$category == 'Information')] <- 17
cleveland2$count[which(cleveland2$type == "Total"&cleveland2$category == 'Clerical')] <- 10
ggplot(cleveland2,aes(x=count,y=fct_reorder2(`category`,type== "Total",count,.desc=FALSE),color = type)) + 
  geom_point() +  
  ggtitle("Residency Requirement for Job Category") +
  ylab("") +
  theme(plot.title = element_text(hjust = 0.5))

```

```{r}
cfjob = job %>% filter(!is.na(`Full-Time/Part-Time indicator`)) 

categ1 = cfjob %>% filter(`Full-Time/Part-Time indicator` %in% c("F", "P")) %>% filter(!is.na(category)) %>% count(category, `Full-Time/Part-Time indicator`)

total_categ1 = cfjob %>% filter(`Full-Time/Part-Time indicator` %in% c("F", "P")) %>% filter(!is.na(category)) %>% count(category)

most_categ1 = total_categ1[order(total_categ1$n, decreasing = TRUE),]

sort_categ1 = categ1 %>% filter(category %in% most_categ1$category)

ggplot() + geom_point(data = sort_categ1, aes(x=n, y=fct_reorder2(`category`,`Full-Time/Part-Time indicator`== "F",n,.desc=FALSE)
, color = `Full-Time/Part-Time indicator`)) + ggtitle("category and Full time / Part time job") + ylab("")
```


```{r}
jobs=job%>% mutate(llevel = case_when(
    str_detect(`Career Level`, "Manager") ~ "Manager",
    str_detect(`Career Level`, "Entry-Level") ~ "Entry-Level",
    str_detect(`Career Level`, "Executive") ~ "Executive",
    str_detect(`Career Level`, "Experienced") ~ "Experienced",
    ))
jobs=jobs%>%filter(!is.na(llevel)) %>%filter(!is.na(degreereq))
```

```{r fig3, fig.height = 5, fig.width = 10,message=FALSE}
library(RColorBrewer)
library(ggmosaic)
jobs$degreereq = fct_relevel(jobs$degreereq, "high school diploma", "associate degree", "bachelor degree","master's degree","Doctorate")
jobs$llevel = fct_relevel(jobs$llevel, "Student", "Entry-Level", "Experienced","Manager","Executive")

ggplot(data = jobs) +
  geom_mosaic(aes(x = product(degreereq,llevel),fill=degreereq)) + 
  labs(title='')+ scale_fill_brewer(palette = "Blues")+xlab('Career Level')+ylab('Degree Requirement')
```


## 5.5

```{r}
D3jobs = job %>% mutate(minSalary = case_when(job$`Salary Frequency`=="Annual" & job$`Salary Range From` <= 25000 ~ "0-25k", job$`Salary Frequency`=="Annual" & job$`Salary Range From` <= 50000 & job$`Salary Range From` > 25000 ~ "25k-50k", job$`Salary Frequency`=="Annual" & job$`Salary Range From` <= 75000 & job$`Salary Range From` > 50000 ~ "50k-75k", job$`Salary Frequency`=="Annual" & job$`Salary Range From` <= 100000 & job$`Salary Range From` > 75000 ~ "75k-100k", job$`Salary Frequency`=="Annual" & job$`Salary Range From` > 100000 ~ ">100k"))

D3jobs = D3jobs %>% filter(!is.na(minSalary))
# write.csv(x = D3jobs, file = "D3jobs.csv", row.names=FALSE)
```

```{r}
library(ggridges)
ggplot(job, aes(x=`Salary Range From` / 1000, y=`Title Classification`)) + geom_density_ridges(alpha=0.6) + xlab("salary range from (unit: 1000 dollar)")
```

```{r}
scatter=job%>%select(`category`, `Job ID`,`Posting Type`) %>%
  drop_na(`Posting Type`) %>%group_by(`category`,`Posting Type`) %>%
  summarise(count = n()) %>%pivot_wider(names_from = `Posting Type`, values_from = count) 

scatter<- scatter %>% 
  mutate(type = case_when(External>Internal*0.8~ "External ",
                          External<Internal*0.6 ~ "Internal",
                          External>Internal*0.6&External<Internal*0.8 ~ "Neutral"))
library(ggrepel)

scatter[is.na(scatter)] <- 0
ggplot(scatter,aes(External, Internal,color=type)) + geom_point()+geom_label_repel(aes(label = scatter$category), size = 3) +
  xlab("External count") +
  ylab("Internal count")
```

```{r}


library(dplyr); 
library(tidytext); 
wordJobs<-job

wordc<-wordJobs%>%
  unnest_tokens(input = `Preferred Skills`, output = word)%>%
  select(word)%>%
  anti_join(stop_words)%>%
  group_by(word)%>%
  summarize(freq = n())%>%
  ungroup()%>%
  arrange(desc(freq))%>%
  top_n(100)

wordc<-wordc%>%
  filter(word!='e9')
wordc<-wordc%>%
  filter(word!='1', word!='0',word!='2'
         ,word!='3',word!='4',word!='5'
         ,word!='6',word!='7',word!='8'
         ,word!='9',word!='10',word!='0080',word!='00a1',word!='0099')



library(wordcloud2)
#wordc include word and word frequency
wordcloud2(wordc,size = 2)
 
```
